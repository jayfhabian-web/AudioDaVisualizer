<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Phonk Engine V42 - Render Edition</title>
    <style>
        /* --- CORE STYLES --- */
        :root { --bg: #050505; --panel: #111; --accent: #ff0033; --text: #ccc; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        * { user-select: none; box-sizing: border-box; }

        /* --- VISUALIZER --- */
        #viewport {
            flex: 1; position: relative; overflow: hidden;
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
            display: flex; justify-content: center; align-items: center;
        }
        canvas.vis-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        #top-controls {
            position: absolute; top: 10px; right: 10px; z-index: 10;
            background: rgba(0,0,0,0.8); padding: 5px; border: 1px solid #333;
            display: flex; gap: 10px;
        }
        
        /* EXPORT OVERLAY */
        #render-status {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); padding: 20px; border: 2px solid var(--accent);
            z-index: 1000; text-align: center; display: none;
        }

        /* --- TIMELINE --- */
        #timeline-area { height: 260px; background: #0e0e0e; border-top: 1px solid #333; display: flex; flex-direction: column; z-index: 20; }
        
        #toolbar {
            height: 40px; background: #151515; display: flex; align-items: center; padding: 0 10px; gap: 10px; border-bottom: 1px solid #222;
        }
        .btn {
            background: #222; border: 1px solid #444; color: #aaa; padding: 4px 8px; font-size: 10px; cursor: pointer; border-radius: 3px;
        }
        .btn:hover { background: #333; color: #fff; }
        .btn.active-tool { background: var(--accent); color: #fff; border-color: var(--accent); }
        
        /* The Canvas Container handles scrolling */
        #timeline-scroll { flex: 1; overflow-x: auto; overflow-y: hidden; position: relative; background: #080808; }
        #tl-canvas { display: block; height: 100%; }

        /* POPUP EDITOR */
        #block-editor {
            position: absolute; display: none; width: 200px;
            background: #1a1a1a; border: 1px solid var(--accent); z-index: 100;
            padding: 10px; box-shadow: 0 0 20px #000; font-size: 10px;
        }
        .ed-row { margin-bottom: 8px; }
        select, input[type=range] { width: 100%; background: #333; color: #fff; border: 1px solid #444; }

    </style>
</head>
<body>

    <div id="viewport">
        <canvas id="c-vis" class="vis-layer"></canvas>
        <canvas id="c-fx" class="vis-layer" style="mix-blend-mode: screen;"></canvas>
        
        <div id="top-controls">
            <button class="btn" id="btn-load">ðŸ“‚ LOAD AUDIO</button>
            <input type="file" id="inp-file" style="display:none" accept="audio/*">
            <span style="border-right:1px solid #444; margin:0 5px;"></span>
            <button class="btn" id="btn-undo">â†¶ UNDO</button>
            <button class="btn" id="btn-redo">â†· REDO</button>
            <span style="border-right:1px solid #444; margin:0 5px;"></span>
            <button class="btn" id="btn-export" style="color:var(--accent);">ðŸ”´ EXPORT VIDEO</button>
        </div>

        <div id="render-status">
            <h2 style="margin:0 0 10px 0; color:var(--accent)">RENDERING...</h2>
            <div style="font-size:12px; color:#aaa;">Please wait. Do not switch tabs.</div>
            <div id="render-prog" style="font-size:20px; font-weight:bold; margin-top:10px;">0%</div>
        </div>
    </div>

    <div id="timeline-area">
        <div id="toolbar">
            <button id="btn-play" class="btn" style="width:60px;">â–¶ PLAY</button>
            
            <div style="display:flex; gap:2px; border-right:1px solid #333; padding-right:10px;">
                <button class="btn active-tool" id="tool-sel" title="Select (V)">V</button>
                <button class="btn" id="tool-split" title="Split (C)">âœ‚</button>
                <button class="btn" id="tool-del" title="Delete (D)">ðŸ—‘</button>
            </div>
            
            <div style="display:flex; gap:5px;">
                <span style="font-size:10px; color:#666;">DRAG:</span>
                <div class="btn" draggable="true" ondragstart="dragStart(event, 'shake')">Shake</div>
                <div class="btn" draggable="true" ondragstart="dragStart(event, 'flash')">Flash</div>
                <div class="btn" draggable="true" ondragstart="dragStart(event, 'glitch')">Glitch</div>
            </div>
        </div>

        <div id="timeline-scroll" ondrop="handleDrop(event)" ondragover="allowDrop(event)">
            <canvas id="tl-canvas"></canvas>
        </div>
        
        <div id="block-editor">
            <div style="display:flex; justify-content:space-between;">
                <strong style="color:var(--accent)">EDIT</strong>
                <button onclick="closeEditor()" style="background:none; border:none; color:#666; cursor:pointer;">x</button>
            </div>
            <div class="ed-row">
                <label>Easing</label>
                <select id="ed-ease" onchange="updateBlock('ease', this.value)">
                    <option value="linear">Linear</option>
                    <option value="inQuad">In Quad</option>
                    <option value="outQuad">Out Quad</option>
                    <option value="bounce">Bounce</option>
                </select>
            </div>
            <div class="ed-row">
                <label>Strength</label>
                <input type="range" id="ed-str" min="0" max="100" oninput="updateBlock('str', this.value)">
            </div>
        </div>
    </div>

    <script>
        // --- HISTORY MODULE ---
        const history = {
            past: [], future: [],
            save: () => {
                history.past.push(JSON.stringify(state.blocks));
                if(history.past.length > 20) history.past.shift();
                history.future = [];
            },
            undo: () => {
                if(history.past.length === 0) return;
                history.future.push(JSON.stringify(state.blocks));
                state.blocks = JSON.parse(history.past.pop());
                redrawTimelineLayer();
            },
            redo: () => {
                if(history.future.length === 0) return;
                history.past.push(JSON.stringify(state.blocks));
                state.blocks = JSON.parse(history.future.pop());
                redrawTimelineLayer();
            }
        };

        // --- STATE MODULE ---
        const state = {
            ctx: null, buf: null, src: null, anal: null,
            play: false, start: 0, pause: 0, dur: 0,
            zoom: 100,
            blocks: [], 
            tool: 'sel', 
            dragObj: null, dragMode: null, selBlock: null,
            
            // Caching
            cacheCanvas: document.createElement('canvas'),
            
            // Rendering
            isRendering: false,
            mediaRecorder: null,
            chunks: []
        };

        const cvs = { tl: document.getElementById('tl-canvas'), vis: document.getElementById('c-vis'), fx: document.getElementById('c-fx') };
        const ctx = { tl: cvs.tl.getContext('2d'), vis: cvs.vis.getContext('2d'), fx: cvs.fx.getContext('2d') };

        // --- INIT ---
        function init() {
            resize(); window.onresize = resize;
            
            // File Load
            document.getElementById('btn-load').onclick = () => document.getElementById('inp-file').click();
            document.getElementById('inp-file').onchange = async (e) => {
                const ab = await e.target.files[0].arrayBuffer();
                state.ctx = new (window.AudioContext||window.webkitAudioContext)();
                state.buf = await state.ctx.decodeAudioData(ab);
                state.dur = state.buf.duration;
                
                // Init Dimensions
                cvs.tl.width = state.cacheCanvas.width = state.dur * state.zoom;
                cvs.tl.height = state.cacheCanvas.height = document.getElementById('timeline-scroll').clientHeight;
                
                renderStaticWaveform(); // Cache it
                redrawTimelineLayer();
            };

            // Controls
            document.getElementById('btn-play').onclick = () => togglePlay();
            document.getElementById('btn-undo').onclick = history.undo;
            document.getElementById('btn-redo').onclick = history.redo;
            document.getElementById('btn-export').onclick = startExport;

            // Tools
            ['sel', 'split', 'del'].forEach(t => {
                document.getElementById(`tool-${t}`).onclick = (e) => {
                    document.querySelectorAll('.active-tool').forEach(b=>b.classList.remove('active-tool'));
                    e.target.classList.add('active-tool');
                    state.tool = t;
                };
            });

            setupTimelineInteraction();
            loop();
        }

        function resize() {
            cvs.vis.width = cvs.fx.width = document.getElementById('viewport').clientWidth;
            cvs.vis.height = cvs.fx.height = document.getElementById('viewport').clientHeight;
        }

        // --- AUDIO ENGINE ---
        function togglePlay(forceTime = null) {
            if(state.isRendering) return;

            if(state.play) {
                // STOP
                if(state.src) state.src.stop();
                state.play = false;
                state.pause = state.ctx.currentTime - state.start;
                document.getElementById('btn-play').innerText = "â–¶ PLAY";
                
                // If forced seek while playing
                if(forceTime !== null) {
                    state.pause = forceTime;
                    togglePlay(); // Restart immediately at new time
                }
            } else {
                // START
                state.src = state.ctx.createBufferSource();
                state.src.buffer = state.buf;
                state.anal = state.ctx.createAnalyser();
                state.src.connect(state.anal);
                state.src.connect(state.ctx.destination);
                
                // If seeking while paused
                if(forceTime !== null) state.pause = forceTime;

                state.start = state.ctx.currentTime - state.pause;
                state.src.start(0, state.pause);
                state.play = true;
                document.getElementById('btn-play').innerText = "â¸ STOP";
            }
            redrawTimelineLayer();
        }

        // --- EXPORT RENDERER ---
        function startExport() {
            if(!state.buf || state.isRendering) return;
            state.isRendering = true;
            document.getElementById('render-status').style.display = 'block';

            // 1. Setup Stream
            const stream = cvs.vis.captureStream(60); // 60 FPS
            
            // 2. Setup Audio Dest
            const dest = state.ctx.createMediaStreamDestination();
            state.src = state.ctx.createBufferSource();
            state.src.buffer = state.buf;
            state.anal = state.ctx.createAnalyser();
            state.src.connect(state.anal);     // To Visualizer
            state.src.connect(dest);           // To Recorder
            state.src.connect(state.ctx.destination); // To Speaker (Monitoring)

            // 3. Add Audio Track to Video Stream
            const audioTrack = dest.stream.getAudioTracks()[0];
            stream.addTrack(audioTrack);

            // 4. Recorder
            state.chunks = [];
            state.mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
            
            state.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) state.chunks.push(e.data);
            };
            
            state.mediaRecorder.onstop = () => {
                const blob = new Blob(state.chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'phonk_visualizer.webm';
                a.click();
                
                // Cleanup
                state.isRendering = false;
                document.getElementById('render-status').style.display = 'none';
                state.play = false;
                document.getElementById('btn-play').innerText = "â–¶ PLAY";
            };

            // 5. Start
            state.mediaRecorder.start();
            state.start = state.ctx.currentTime;
            state.src.start(0); // Play from start
            state.play = true;

            // 6. Stop when done
            state.src.onended = () => {
                state.mediaRecorder.stop();
            };
        }

        // --- TIMELINE INTERACTION ---
        function setupTimelineInteraction() {
            let startX=0, origStart=0, origDur=0;

            cvs.tl.onmousedown = (e) => {
                if(!state.buf || state.isRendering) return;
                
                const rect = cvs.tl.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const t = x / state.zoom;
                
                // Hit Test
                const hit = state.blocks.find(b => t >= b.start && t <= b.start + b.dur);
                
                // ACTION: SEEKING (If no block clicked OR tool isn't Select/Split/Del)
                // Actually, if we click empty space, we ALWAYS seek.
                if(!hit) {
                    togglePlay(t); // Seek to t
                    return;
                }

                // If we hit a block...
                history.save();

                if(state.tool === 'del') {
                    state.blocks = state.blocks.filter(b => b !== hit);
                    redrawTimelineLayer();
                    return;
                }
                
                if(state.tool === 'split') {
                    const offset = t - hit.start;
                    const newDur = hit.dur - offset;
                    hit.dur = offset;
                    const newBlock = { ...hit, id: Date.now(), start: t, dur: newDur };
                    state.blocks.push(newBlock);
                    redrawTimelineLayer();
                    return;
                }

                if(state.tool === 'sel') {
                    state.selBlock = hit;
                    openEditor(hit, e.clientX, e.clientY);
                    
                    const pxStart = hit.start * state.zoom;
                    const pxEnd = (hit.start + hit.dur) * state.zoom;
                    
                    if(Math.abs(x - pxStart) < 10) { state.dragMode = 'resize-l'; state.dragObj = hit; }
                    else if(Math.abs(x - pxEnd) < 10) { state.dragMode = 'resize-r'; state.dragObj = hit; }
                    else { state.dragMode = 'move'; state.dragObj = hit; }
                    
                    startX = x;
                    origStart = hit.start;
                    origDur = hit.dur;
                }
            };

            window.onmousemove = (e) => {
                if(state.isRendering) return;
                const rect = cvs.tl.getBoundingClientRect();
                const x = e.clientX - rect.left;
                
                // Cursor logic
                if(!state.dragMode) {
                    const t = x / state.zoom;
                    const hit = state.blocks.find(b => t >= b.start && t <= b.start + b.dur);
                    if(hit && state.tool === 'sel') cvs.tl.style.cursor = 'move';
                    else if(hit && state.tool === 'split') cvs.tl.style.cursor = 'crosshair';
                    else cvs.tl.style.cursor = 'default';
                }

                if(state.dragObj && state.dragMode) {
                    const dx = (x - startX) / state.zoom;
                    if(state.dragMode === 'move') state.dragObj.start = origStart + dx;
                    else if(state.dragMode === 'resize-r') state.dragObj.dur = Math.max(0.1, origDur + dx);
                    redrawTimelineLayer();
                }
            };

            window.onmouseup = () => { state.dragObj = null; state.dragMode = null; };
        }

        // --- DRAG & DROP ---
        window.dragStart = (e, type) => { e.dataTransfer.setData('type', type); };
        window.allowDrop = (e) => e.preventDefault();
        window.handleDrop = (e) => {
            e.preventDefault();
            history.save();
            const rect = document.getElementById('timeline-scroll').getBoundingClientRect();
            const scroll = document.getElementById('timeline-scroll').scrollLeft;
            const x = (e.clientX - rect.left) + scroll;
            const t = x / state.zoom;
            state.blocks.push({ id: Date.now(), type: e.dataTransfer.getData('type'), start: t, dur: 1.0, str: 50, ease: 'linear' });
            redrawTimelineLayer();
        };

        // --- RENDERERS ---
        function renderStaticWaveform() {
            const c = state.cacheCanvas.getContext('2d');
            const w = state.cacheCanvas.width;
            const h = state.cacheCanvas.height;
            const data = state.buf.getChannelData(0);
            const step = Math.ceil(data.length / w);
            
            c.fillStyle = '#111'; c.fillRect(0,0,w,h);
            
            // Draw Wave with HEADROOM
            c.fillStyle = '#555';
            for(let i=0; i<w; i++) {
                let min=1.0, max=-1.0;
                for(let j=0; j<step; j++) {
                    const d = data[(i*step)+j];
                    if(d<min)min=d; if(d>max)max=d;
                }
                const y = (1+min)*(h/2)*0.8 + (h*0.1);
                const ht = Math.max(1, (max-min)*(h/2)*0.8);
                c.fillRect(i, y, 1, ht);
            }
        }

        function redrawTimelineLayer() {
            if(!state.buf) return;
            const c = ctx.tl;
            const w = cvs.tl.width; const h = cvs.tl.height;
            
            c.drawImage(state.cacheCanvas, 0, 0); // Blit BG
            
            state.blocks.forEach(b => {
                const x = b.start * state.zoom;
                const bw = b.dur * state.zoom;
                
                if(b.type==='shake') c.fillStyle = 'rgba(255, 50, 50, 0.5)';
                else if(b.type==='flash') c.fillStyle = 'rgba(255, 255, 255, 0.5)';
                else c.fillStyle = 'rgba(50, 150, 255, 0.5)';
                
                if(state.selBlock === b) { c.strokeStyle='#fff'; c.strokeRect(x,10,bw,h-20); }
                c.fillRect(x,10,bw,h-20);
                c.fillStyle='#fff'; c.fillText(b.type, x+2, 22);
            });
        }

        function loop() {
            requestAnimationFrame(loop);
            const t = state.play ? (state.ctx.currentTime - state.start) : state.pause;
            
            if(state.isRendering) {
                const prog = Math.floor((t / state.dur) * 100);
                document.getElementById('render-prog').innerText = prog + '%';
            }

            if(state.buf) {
                // Playhead (Lazy Draw)
                redrawTimelineLayer(); 
                const px = t * state.zoom;
                ctx.tl.fillStyle = '#ff0033'; ctx.tl.fillRect(px, 0, 2, cvs.tl.height);
                
                if(state.play) {
                    const scr = document.getElementById('timeline-scroll');
                    if(px > scr.scrollLeft + scr.clientWidth - 50) scr.scrollLeft = px - 100;
                }
            }

            // Visualizer (Simple)
            if(state.play || state.isRendering) {
                let shake = 0;
                let flash = 0;
                let invert = 0;
                state.blocks.forEach(b => {
                    if(t >= b.start && t < b.start + b.dur) {
                        if(b.type==='shake') shake += (b.str/100);
                        if(b.type==='flash') flash += (b.str/100);
                    }
                });

                const c = ctx.vis;
                const w = cvs.vis.width; const h = cvs.vis.height;
                
                c.fillStyle = `rgba(0,0,0,${0.2})`; // Trails
                c.fillRect(0,0,w,h);
                
                c.save();
                if(shake>0) {
                    const s = shake*30;
                    c.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
                }
                
                // Draw circle vis
                let freq = new Uint8Array(state.anal.frequencyBinCount);
                state.anal.getByteFrequencyData(freq);
                
                c.beginPath();
                const rad = 150;
                for(let i=0; i<100; i++) {
                    const v = freq[i*3]/255;
                    const ang = (i/100)*Math.PI*2;
                    const len = v * 200;
                    c.moveTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                    c.lineTo(Math.cos(ang)*(rad+len), Math.sin(ang)*(rad+len));
                }
                c.strokeStyle = '#ff0033'; c.lineWidth=3; c.stroke();
                c.restore();

                // FX
                const fc = ctx.fx;
                fc.clearRect(0,0,w,h);
                if(flash>0) {
                    fc.fillStyle = `rgba(255,255,255,${flash})`;
                    fc.fillRect(0,0,w,h);
                }
            }
        }

        window.openEditor = (b, x, y) => {
            const el = document.getElementById('block-editor');
            el.style.display = 'block';
            el.style.left = Math.min(window.innerWidth-220, x)+'px';
            el.style.top = Math.min(window.innerHeight-200, y-100)+'px';
            document.getElementById('ed-str').value = b.str;
        };
        window.closeEditor = () => document.getElementById('block-editor').style.display='none';
        window.updateBlock = (k, v) => { if(state.selBlock) state.selBlock[k]=v; redrawTimelineLayer(); };

        init();
    </script>
</body>
</html>
