<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Phonk Engine V39 - Pro Editor</title>
    <style>
        :root {
            --bg: #050505;
            --panel: #111;
            --border: #333;
            --accent: #ff0033;
            --accent-dim: #550011;
            --text: #ccc;
            --block-base: rgba(100, 100, 100, 0.5);
        }
        * { box-sizing: border-box; user-select: none; font-family: 'Segoe UI', sans-serif; }
        body { margin: 0; background: var(--bg); color: var(--text); overflow: hidden; height: 100vh; display: flex; flex-direction: column; }

        /* --- TOP SECTION (Visualizer) --- */
        #viewport {
            flex: 1; position: relative; overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            background: radial-gradient(circle, #1a1a1a 0%, #000 100%);
        }
        canvas.vis-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* UI OVERLAY (Top Left) */
        #settings-overlay {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid var(--border); border-radius: 5px;
            backdrop-filter: blur(5px);
        }
        .control-row { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; font-size: 11px; }
        input[type="range"] { flex: 1; height: 4px; -webkit-appearance: none; background: #444; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; background: #fff; border-radius: 50%; cursor: pointer; }

        /* --- BOTTOM SECTION (Timeline) --- */
        #timeline-area {
            height: 220px; background: var(--panel); border-top: 1px solid var(--border);
            display: flex; flex-direction: column; position: relative; z-index: 200;
        }

        /* TOOLBAR */
        #toolbar {
            height: 40px; background: #181818; display: flex; align-items: center; padding: 0 10px; gap: 10px;
            border-bottom: 1px solid #222;
        }
        .tool-btn {
            padding: 5px 10px; background: #333; border: 1px solid #444; color: #aaa;
            font-size: 10px; text-transform: uppercase; cursor: pointer; border-radius: 3px;
            font-weight: bold; letter-spacing: 0.5px;
        }
        .tool-btn:hover { background: #444; color: #fff; }
        .tool-btn.active { background: var(--accent); color: #fff; border-color: var(--accent); box-shadow: 0 0 10px var(--accent-dim); }
        .divider { width: 1px; height: 20px; background: #444; margin: 0 5px; }

        /* TIMELINE CANVAS */
        #timeline-scroll {
            flex: 1; position: relative; overflow-x: auto; overflow-y: hidden;
            background: #080808; cursor: crosshair;
        }
        #tl-canvas { display: block; height: 100%; }
        
        /* SCROLLBAR STYLE */
        #timeline-scroll::-webkit-scrollbar { height: 8px; background: #111; }
        #timeline-scroll::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

        /* POPUP EDITOR */
        #block-editor {
            position: absolute; display: none; width: 200px;
            background: rgba(20, 20, 20, 0.95); border: 1px solid var(--accent);
            box-shadow: 0 5px 20px rgba(0,0,0,0.8); z-index: 500;
            padding: 10px; border-radius: 4px;
        }
        #block-editor h3 { margin: 0 0 10px 0; font-size: 11px; color: var(--accent); text-transform: uppercase; border-bottom: 1px solid #333; padding-bottom: 5px; }
        .ed-row { margin-bottom: 8px; font-size: 10px; }
        .ed-row label { display: block; color: #888; margin-bottom: 3px; }
        .ed-row input[type="number"] { background: #333; border: 1px solid #444; color: #fff; padding: 3px; width: 100%; }
        .ed-row button.del { width: 100%; background: #500; color: #faa; border: none; padding: 5px; cursor: pointer; margin-top: 5px; }

    </style>
</head>
<body>

    <div id="viewport">
        <div id="settings-overlay">
            <div class="control-row">
                <button id="btn-load">ðŸ“‚ LOAD AUDIO</button>
                <input type="file" id="inp-file" accept="audio/*" style="display:none">
            </div>
            <div class="control-row">
                <span>VIS SCALE:</span>
                <input type="range" id="master-scale" min="0.5" max="2.0" step="0.1" value="1.0">
            </div>
            <div class="control-row">
                <span>BG DIM:</span>
                <input type="range" id="bg-dim" min="0" max="1" step="0.1" value="0.5">
            </div>
        </div>

        <canvas id="c-vis" class="vis-layer"></canvas>
        <canvas id="c-fx" class="vis-layer" style="mix-blend-mode: overlay;"></canvas>
    </div>

    <div id="timeline-area">
        <div id="toolbar">
            <span style="font-size:10px; font-weight:bold; color:#666;">TOOLS:</span>
            <button class="tool-btn active" data-type="shake">Shake</button>
            <button class="tool-btn" data-type="flash">Flash</button>
            <button class="tool-btn" data-type="invert">Invert</button>
            <button class="tool-btn" data-type="glitch">Glitch</button>
            <button class="tool-btn" data-type="blur">Blur</button>
            
            <div class="divider"></div>
            
            <button class="tool-btn" id="btn-play">â–¶ PLAY</button>
            <span id="time-display" style="margin-left:auto; font-family:monospace; font-size:11px;">00:00.00</span>
        </div>

        <div id="timeline-scroll">
            <canvas id="tl-canvas"></canvas>
        </div>
        
        <div id="block-editor">
            <h3>Effect Settings</h3>
            <div class="ed-row">
                <label>Strength (0-100)</label>
                <input type="range" id="ed-str" min="0" max="100" value="50">
            </div>
            <div class="ed-row">
                <label>Tweening (Fade Out)</label>
                <input type="checkbox" id="ed-fade"> Enable Smooth Exit
            </div>
            <button class="del" id="ed-del">DELETE BLOCK</button>
        </div>
    </div>

    <script>
        // --- CORE STATE ---
        const state = {
            audioCtx: null, buffer: null, source: null, analyser: null,
            startTime: 0, pausedAt: 0, isPlaying: false,
            duration: 0,
            
            // Viewport
            scale: 1.0,
            
            // Timeline
            zoom: 100, // pixels per second
            blocks: [], // { id, type, start, dur, str, fade }
            activeTool: 'shake',
            selectedBlock: null,
            
            // Runtime FX values
            fx: { shake:0, flash:0, invert:0, glitch:0, blur:0 }
        };

        const cvs = {
            vis: document.getElementById('c-vis'),
            fx: document.getElementById('c-fx'),
            tl: document.getElementById('tl-canvas')
        };
        const ctx = {
            vis: cvs.vis.getContext('2d'),
            fx: cvs.fx.getContext('2d'),
            tl: cvs.tl.getContext('2d')
        };

        // --- INITIALIZATION ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            setupUI();
            requestAnimationFrame(loop);
        }

        function resize() {
            cvs.vis.width = cvs.fx.width = document.getElementById('viewport').clientWidth;
            cvs.vis.height = cvs.fx.height = document.getElementById('viewport').clientHeight;
            drawTimeline();
        }

        function setupUI() {
            // Audio Load
            document.getElementById('btn-load').onclick = () => document.getElementById('inp-file').click();
            document.getElementById('inp-file').onchange = async (e) => {
                const f = e.target.files[0];
                const ab = await f.arrayBuffer();
                state.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
                state.buffer = await state.audioCtx.decodeAudioData(ab);
                state.duration = state.buffer.duration;
                
                // Resize timeline canvas based on duration
                cvs.tl.width = state.duration * state.zoom;
                cvs.tl.height = document.getElementById('timeline-scroll').clientHeight;
                
                drawTimeline();
            };

            // Playback
            document.getElementById('btn-play').onclick = togglePlay;
            
            // Scale
            document.getElementById('master-scale').oninput = (e) => state.scale = parseFloat(e.target.value);

            // Tools
            document.querySelectorAll('.tool-btn[data-type]').forEach(btn => {
                btn.onclick = () => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.activeTool = btn.dataset.type;
                };
            });

            // Timeline Interaction
            cvs.tl.addEventListener('mousedown', handleTimelineClick);
            
            // Editor Controls
            document.getElementById('ed-str').oninput = (e) => {
                if(state.selectedBlock) { state.selectedBlock.str = parseInt(e.target.value); drawTimeline(); }
            };
            document.getElementById('ed-fade').onchange = (e) => {
                if(state.selectedBlock) { state.selectedBlock.fade = e.target.checked; }
            };
            document.getElementById('ed-del').onclick = () => {
                if(state.selectedBlock) {
                    state.blocks = state.blocks.filter(b => b !== state.selectedBlock);
                    closeEditor();
                    drawTimeline();
                }
            };
        }

        // --- AUDIO ENGINE ---
        function togglePlay() {
            if(state.isPlaying) {
                state.source.stop(); state.isPlaying = false;
                state.pausedAt = state.audioCtx.currentTime - state.startTime;
                document.getElementById('btn-play').innerText = "â–¶ PLAY";
            } else {
                state.source = state.audioCtx.createBufferSource();
                state.source.buffer = state.buffer;
                state.analyser = state.audioCtx.createAnalyser();
                state.source.connect(state.analyser);
                state.source.connect(state.audioCtx.destination);
                state.startTime = state.audioCtx.currentTime - state.pausedAt;
                state.source.start(0, state.pausedAt);
                state.isPlaying = true;
                document.getElementById('btn-play').innerText = "â¸ STOP";
            }
        }

        // --- RENDER LOOP ---
        function loop() {
            requestAnimationFrame(loop);
            
            // 1. Calculate Time
            const t = state.isPlaying ? (state.audioCtx.currentTime - state.startTime) : state.pausedAt;
            if(state.isPlaying) {
                updateTimeDisplay(t);
                drawTimelinePlayhead(t);
            }

            // 2. Process Timeline Blocks (Tweening Logic)
            Object.keys(state.fx).forEach(k => state.fx[k] = 0); // Reset
            
            state.blocks.forEach(b => {
                if(t >= b.start && t < b.start + b.dur) {
                    let val = b.str / 100; // Normalize 0-1
                    
                    // Tweening (Ease Out)
                    if(b.fade) {
                        const progress = (t - b.start) / b.dur;
                        if(progress > 0.7) { // Fade out last 30%
                            const fadeP = (progress - 0.7) / 0.3;
                            val *= (1 - fadeP);
                        }
                    }
                    state.fx[b.type] += val;
                }
            });

            // 3. Audio Data
            let freq = new Uint8Array(0);
            if(state.isPlaying) {
                freq = new Uint8Array(state.analyser.frequencyBinCount);
                state.analyser.getByteFrequencyData(freq);
            }

            // 4. Render Visuals
            renderVisuals(freq);
        }

        function renderVisuals(data) {
            const w = cvs.vis.width; const h = cvs.vis.height;
            const c = ctx.vis;
            
            // Clear
            c.fillStyle = `rgba(0,0,0,${0.1 + state.fx.blur*0.5})`; // Trail effect
            c.fillRect(0,0,w,h);

            // Apply Shake
            const shakeAmt = state.fx.shake * 50;
            const dx = (Math.random()-0.5)*shakeAmt;
            const dy = (Math.random()-0.5)*shakeAmt;
            
            c.save();
            c.translate(w/2 + dx, h/2 + dy);
            c.scale(state.scale + state.fx.shake*0.1, state.scale + state.fx.shake*0.1);

            // Draw Circle Vis
            if(data.length) {
                const rad = 150;
                const bars = 60;
                c.beginPath();
                for(let i=0; i<bars; i++) {
                    const val = data[i*2] / 255;
                    const ang = (i/bars) * Math.PI * 2;
                    const len = val * 200 * (1 + state.fx.invert); // Invert makes bars huge
                    
                    const x = Math.cos(ang) * (rad + len);
                    const y = Math.sin(ang) * (rad + len);
                    
                    // Color Logic
                    if(state.fx.invert > 0.5) c.strokeStyle = '#fff';
                    else c.strokeStyle = `hsl(${i*5}, 100%, 50%)`;
                    
                    c.lineWidth = 5 + state.fx.glitch*10;
                    
                    // Draw line from center-ish out
                    c.moveTo(Math.cos(ang)*rad, Math.sin(ang)*rad);
                    c.lineTo(x, y);
                }
                c.stroke();
            }

            c.restore();

            // FX Overlays
            const fxC = ctx.fx;
            fxC.clearRect(0,0,w,h);
            
            // Flash
            if(state.fx.flash > 0) {
                fxC.fillStyle = `rgba(255,255,255,${state.fx.flash * 0.5})`;
                fxC.fillRect(0,0,w,h);
            }
            
            // Invert (CSS Filter trick)
            cvs.vis.style.filter = `invert(${state.fx.invert * 100}%) blur(${state.fx.blur * 10}px)`;
        }

        // --- TIMELINE DRAWING ---
        function drawTimeline() {
            const c = ctx.tl;
            const w = cvs.tl.width; const h = cvs.tl.height;
            c.fillStyle = '#0a0a0a'; c.fillRect(0,0,w,h);
            
            if(!state.buffer) {
                c.fillStyle = '#333'; c.font = '20px Arial'; c.fillText("LOAD AUDIO TO EDIT", 20, 50);
                return;
            }

            // 1. Draw Bass Map (Heatmap) - Background
            const data = state.buffer.getChannelData(0);
            const step = Math.ceil(data.length / w);
            
            c.fillStyle = '#300'; // Dark Red for Bass
            for(let i=0; i<w; i+=2) {
                // Simple cheap low-pass sim: average a larger chunk
                let sum = 0;
                for(let j=0; j<step*4; j++) {
                    if(data[i*step + j]) sum += Math.abs(data[i*step + j]);
                }
                const bassVal = sum / (step*4);
                if(bassVal > 0.3) { // Threshold
                    c.fillRect(i, h/2 - bassVal*h*0.8, 2, bassVal*h*1.6);
                }
            }

            // 2. Draw Main Waveform - Foreground
            c.fillStyle = '#444';
            c.beginPath();
            for(let i=0; i<w; i++) {
                let max = 0;
                for(let j=0; j<step; j++) {
                    const v = Math.abs(data[i*step+j]);
                    if(v>max) max=v;
                }
                c.fillRect(i, h/2 - max*h*0.4, 1, max*h*0.8);
            }

            // 3. Draw Blocks
            state.blocks.forEach(b => {
                const x = b.start * state.zoom;
                const width = b.dur * state.zoom;
                
                // Color based on type
                if(b.type === 'shake') c.fillStyle = 'rgba(255, 50, 50, 0.6)';
                else if(b.type === 'flash') c.fillStyle = 'rgba(255, 255, 255, 0.6)';
                else c.fillStyle = 'rgba(50, 150, 255, 0.6)';
                
                if(state.selectedBlock === b) {
                    c.strokeStyle = '#fff'; c.lineWidth = 2;
                    c.strokeRect(x, 10, width, h-20);
                }
                
                c.fillRect(x, 10, width, h-20);
                
                // Label
                c.fillStyle = '#fff'; c.font = '10px Arial';
                c.fillText(b.type, x+2, 25);
                
                // Tween Line
                if(b.fade) {
                    c.strokeStyle = '#fff'; c.beginPath();
                    c.moveTo(x, 30);
                    c.lineTo(x + width*0.7, 30);
                    c.lineTo(x + width, 40); // Dip down
                    c.stroke();
                }
            });
        }

        function drawTimelinePlayhead(t) {
            // Re-draw bg + blocks first (not efficient, but clean)
            drawTimeline();
            const x = t * state.zoom;
            const c = ctx.tl;
            c.fillStyle = '#ff0033';
            c.fillRect(x, 0, 2, cvs.tl.height);
            
            // Auto scroll
            const scroll = document.getElementById('timeline-scroll');
            if(x > scroll.scrollLeft + scroll.clientWidth - 50) {
                scroll.scrollLeft = x - 100;
            }
        }

        function handleTimelineClick(e) {
            if(!state.buffer) return;
            const rect = cvs.tl.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const t = x / state.zoom;
            
            // 1. Check if clicking existing block
            const clicked = state.blocks.find(b => t >= b.start && t <= b.start + b.dur);
            
            if(clicked) {
                selectBlock(clicked, e.clientX, e.clientY);
            } else {
                // 2. Create New Block
                const newBlock = {
                    id: Date.now(),
                    type: state.activeTool,
                    start: t,
                    dur: 0.5, // Default 0.5s
                    str: 50,
                    fade: false
                };
                state.blocks.push(newBlock);
                selectBlock(newBlock, e.clientX, e.clientY);
            }
        }

        function selectBlock(block, mx, my) {
            state.selectedBlock = block;
            drawTimeline();
            
            // Open Editor
            const ed = document.getElementById('block-editor');
            ed.style.display = 'block';
            
            // Position near click but keep in bounds
            ed.style.left = Math.min(window.innerWidth - 220, mx + 10) + 'px';
            ed.style.top = Math.min(window.innerHeight - 150, my - 50) + 'px';
            
            // Populate
            document.getElementById('ed-str').value = block.str;
            document.getElementById('ed-fade').checked = block.fade;
        }

        function closeEditor() {
            document.getElementById('block-editor').style.display = 'none';
            state.selectedBlock = null;
        }

        function updateTimeDisplay(t) {
            const m = Math.floor(t/60).toString().padStart(2,'0');
            const s = (t%60).toFixed(2).padStart(5,'0');
            document.getElementById('time-display').innerText = `${m}:${s}`;
        }

        init();
    </script>
</body>
</html>
